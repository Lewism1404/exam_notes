A a

```sql
SELECT COUNT(*)
FROM (
    SELECT V.MID
    VEHICLE as V
    WHERE V.YEAR >= 2020
    GROUP BY V.MID
    HAVING COUNT(*) > 500
) AS SubQuery
```

A b

```sql
SELECT Name, RID
FROM (
    SELECT INN.TID AS RID, R.Name as Name, RANK() OVER (ORDER BY INN.COUNTERS ASC) AS RANKING
    FROM(
        SELECT TID AS TID, COUNT(*) AS COUNTERS
        FROM SALES GROUP BY TID
    ) AS INN, RETAILER AS R
    WHERE R.RID = INN.TID
) as RES
WHERE RANKING = 1
```

Chat:
```sql
SELECT R.Name, R.RID
FROM RETAILER R
JOIN SALES S ON R.RID = S.TID
GROUP BY R.RID, R.Name
HAVING COUNT(*) = (
    SELECT MIN(VehicleCount)
    FROM (
        SELECT COUNT(*) AS VehicleCount
        FROM SALES
        GROUP BY TID
    ) AS Counts
);
```

B a

blocking factor of B/R = 2

Since we have 2,000 distinct salary values uniformly distributed, we must have 2,000/10 = 200 leaf nodes

Each salary has 40,000/2,000 = 20 records => 10 blocks

Each leaf node block pointer will point to a block of pointers, this block of pointers will hold 10 pointers

We can fit 10 pointers as bfr for pointer blocks is floor(1024/100) = 10.

Root: 1 node with 5 pointers, 4 salary values
level 1: 5 nodes with 5*5 = 25 pointers, 5*4 = 20 salary values
level 2: 25 nodes with 25*5 = 125 pointers, 25*4 = 100 salary values
level 3: 125 nodes with 125*5 = 625 pointers, 125*4 = 500 salary values
level 4 (leaf nodes): 625 leaf nodes with 625*10 = 6250 pointers, 6250 salary values and 625 sibling pointers

UG layer: 6250 pointers to 6250 pointer blocks.

B b

You will have to access root plus all 4 layers to get to the leaf nodes, then you will have to access the pointer block which then you will have to read all 10 blocks to get all of the data:

1 + 4 + 1 + 10 = 16 blocks accesses.

B c

We must have less than 16 block accesses to be better than the B+ Tree.

Since the hash function uniformly distributes the salaries we can have no more than 10 blocks per bucket (20 tuples per bucket).

Since we have 2000 distinct salaries, we should have M = 2000 buckets.

Resulting in 10 block accesses when using this hash function.

C a


C b

Clustering index over AGE (non key):




B+ Tree

50 + 200(3) + 50

50 to load
600 to find each employee matching the manager
50 to create the result

cost for the selection condition is 50, load in 50 blocks to memory and loop through them to match the conditions, plus 5 blocks to store the output

total = 600 + (50 + 5) = 655

maybe you don't need the extra 50 blocks saving and loading

so maybe 655.

Primary Index

24

A a

```sql
SELECT Count(*)
FROM (
    SELECT ID, Count(*)
    FROM FLIGHT
    GROUP BY ID
    HAVING COUNT(*) > 10
) as SubQuery
```

A b

```sql
SELECT AL.Name
FROM (
    SELECT AC, Count(*)
    FROM AIRPLANE
    GROUP BY AC
    HAVING COUNT(*) > 10
) as SubQuery, AIRLINE as AL
WHERE AC = AL.AC AND EXISTS (
    SELECT *
    FROM AIRPLANE AS AP, FLIGHT AS F
    WHERE AL.AC = AP.AC AND F.ID = AP.ID AND F.DepartureAirport == "LHR"
) AND EXISTS (
    SELECT *
    FROM AIRPLANE AS AP, FLIGHT AS F
    WHERE AL.AC = AP.AC AND F.ID = AP.ID AND F.DepartureAirport == "GLA"
)
```

B a

We will group the block addresses of those records having the same value, then assign an index entry per group of block addresses, a cluster points to a block pointer that points to the data-block that has records with this distinct index value.

in the level 1, we have entries like (distinct departure, cluster pointer)

then each entry in one cluster points to a block containing one at least one record of the value associated with that cluster.

We need 5 layers in the index including the data layer

Since we have that a block size is B = 1024 and P = 128

We have that the blocking factor for the level 1 layer is 1024/(128 + 128) = 4

This means we need 4000/4 = 1000 blocks for the level 1 index

These then point to 8 more blocks.

- layer 1: 4000 pointers, 1000 blocks
- layer 2: 8 * 1000 = 8000 pointers, 1000 blocks
- layer 3: 8 * 8000 = 64000 pointers, 8000 blocks
- layer 4: 8 * 64000 = 512000 pointers, 64000 blocks

Now we have enough layers to point to all 400,000 records

B b

Since we have that a block size is B = 1024 and P = 128

We have that the blocking factor for the level 1 layer is 1024/(128 + 128) = 4

This means we need 4000/4 = 1000 blocks for the level 1 index

Then each block points to a cluster with

B